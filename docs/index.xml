<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>L√©o Lima on L√©o Lima</title>
    <link>https://tsleolima.github.io/portfolio-vis/</link>
    <description>Recent content in L√©o Lima on L√©o Lima</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2018 Leonardo Lima</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="/portfolio-vis/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Meu Top 50 no Spotify</title>
      <link>https://tsleolima.github.io/portfolio-vis/post/meutop50/</link>
      <pubDate>Fri, 16 Mar 2018 22:35:55 -0300</pubDate>
      
      <guid>https://tsleolima.github.io/portfolio-vis/post/meutop50/</guid>
      <description>&lt;p&gt;Ol√° a todos, dessa vez estou dando uma passadinha r√°pida para mostrar a voc√™s uma nova visualiza√ß√£o com os meus dados do spotify, eu espero que gostem, daqui alguns dias tentarei se possivel trazer uma intera√ß√£o para esse tipo de visualiza√ß√£o, onde voc√™s veram seus &amp;ldquo;tops 50 spotify artists&amp;rdquo; üòú, no mesmo formato que esse aqui de baixo, espero que gostem e deixem seu Like üëç, hahaha üòÇ.&lt;/p&gt;

&lt;p&gt;&lt;link rel=&#34;stylesheet&#34; href=&#34;https://cdn.rawgit.com/tsleolima/portfolio-vis/ed55de71/content/meuTop50js/css/style.css&#34;&gt;
&lt;!-- Main --&gt;
&lt;div id=&#34;main&#34;&gt;
    &lt;div class=&#34;box container&#34;&gt;
        &lt;section&gt;
            &lt;svg width=&#34;930&#34; height=&#34;630&#34;&gt;
                &lt;defs&gt;
                    &lt;filter id=&#34;greyscale&#34;&gt;
                        &lt;feColorMatrix
                                type=&#34;matrix&#34;
                                values=&#34;0 1 0 0 0
                  0 1 0 0 0
                  0 1 0 0 0
                  0 1 0 1 0 &#34;&gt;
                        &lt;/feColorMatrix&gt;
                    &lt;/filter&gt;
                &lt;/defs&gt;
            &lt;/svg&gt;
        &lt;/section&gt;
    &lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Cr√©ditos ao criador: https://github.com/ss1993/my-spotify-top50
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- Scripts --&gt;

&lt;script src=&#34;https://cdn.rawgit.com/tsleolima/portfolio-vis/ed55de71/content/meuTop50js/js/jquery.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;https://cdn.rawgit.com/tsleolima/portfolio-vis/ed55de71/content/meuTop50js/js/skel.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;https://cdn.rawgit.com/tsleolima/portfolio-vis/ed55de71/content/meuTop50js/js/util.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;https://cdn.rawgit.com/tsleolima/portfolio-vis/ed55de71/content/meuTop50js/js/main.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;https://d3js.org/d3.v4.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.24.0/d3-legend.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;https://cdn.rawgit.com/tsleolima/portfolio-vis/ed55de71/content/meuTop50js/js/music_graph.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>LabRedes</title>
      <link>https://tsleolima.github.io/portfolio-vis/post/labredes/</link>
      <pubDate>Mon, 12 Mar 2018 21:48:58 -0300</pubDate>
      
      <guid>https://tsleolima.github.io/portfolio-vis/post/labredes/</guid>
      <description>&lt;p&gt;Bem vindos novamente a outro post, espero que estejam aqui para aprender mais uma vez sobre algo relacionado a visualiza√ß√£o de dados usando nossa velha amiga D3, e bem, se voc√™ caiu de paraquedas aqui, meu caro amigo leitor, n√£o se intimide, continue lendo e brinque com a visualiza√ß√£o üòÑ.&lt;/p&gt;

&lt;p&gt;Bem, a ideia √© trazer para voc√™s algum dado sobre o gr√°fico logo abaixo, mas vou fazer diferente hoje, dessa vez, vou dar as diretivas para voc√™s irem buscar como fazer a de voc√™s mesmos üòâ.&lt;/p&gt;

&lt;p&gt;Como eu disse, para quem caiu aqui de paraquedas, aconselho estudar um pouco sobre javascript,d3,html, mas n√£o fique triste, a internet est√° ai aberta para conseguirmos aprender tudo isso, ent√£o, n√£o desistam üí™.&lt;/p&gt;

&lt;p&gt;Assumindo que voc√™s camaradas, j√° possuem certos dominios em cria√ß√£o de visualiza√ß√µes atrav√©s da ferramenta &amp;lsquo;D3&amp;rsquo;, irei dar-lhes um exemplo de como √© representado um n√≥ e suas arestas,&lt;/p&gt;

&lt;p&gt;Podemos representar um n√≥ dessa maneira:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var node_data = [&#39;id1&#39;, &#39;id2&#39;, &#39;id3&#39;]; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;e nossas arestas dessa maneira:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var edge_data = [
        {source: &#39;id1&#39;, target:&#39;id2&#39;, weight: 10.0},
        {source: &#39;id2&#39;, target:&#39;id3&#39;, weight: 20.0}, 
        {source: &#39;id3&#39;, target:&#39;id1&#39;, weight: 30.0}
    ];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Por motivos de hora, n√£o posso explicar detalhadamente, entretanto, √© aconselhavel seguir esse padr√£o, para irmos at√© o proximo passo.&lt;/p&gt;

&lt;p&gt;Bem, um dos meus maiores desejos desde o dia em que me foi apresentado esse tipo de visualiza√ß√£o, era a de detectar clusters ou agrupamentos de n√≥s e separa-los por cores, afim de descobrir alguma informa√ß√£o atrav√©s dessa visualiza√ß√£o, mas nossos amigos que trabalham com Grafos em si, j√° descobriram isso para n√≥s, e podemos usar algoritmos que realizam essas opera√ß√µes para conseguirmos extrair essas informa√ß√µes ou at√© mesmo aproveitar a vista, como est√£o fazendo os que cairam de paraquedas aqui üòÅ.
Buscando na internet com meu professor, descobrimos que existe um script j√° desenvolvido para isso, chamado jLouvain, e essas formas de representa√ß√£o de n√≥s e arestas estavam no git dos responsaveis a qual deixarei logo abaixo, mas vou dizer para voc√™s, n√£o foi facil associar a API do Spotify com os artistas semelhantes ao Nando Reis ( escolhi por ser muito f√£, e por outros motivos que supostamente voc·∫Ωs devem desconfiar üíú, sim, √© amor üòå)
Ent√£o deixarei aqui, apenas o link da API do Spotify.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    https://developer.spotify.com/web-api/get-related-artists/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L√° voc√™s encontraram detalhadamente pela pr√≥pria equipe do Spotify, como usar esses dados, lembrando que essas dados s√£o em redes, visto que temos indica√ß√µes do Spotify quando estamos procurando algum artista, ent√£o, √© sugerido que o sistema nos indique artistas com sons semelhante ao qual nos estamos escutando, n√£o √© verdade ? üëç&lt;/p&gt;

&lt;p&gt;Bem, as dificuldades que senti ao formar esses clusters mesmo usando o script do jLouvain&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    https://github.com/upphiminn/jLouvain
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Foi em como o json recebido pela api do spotify tinha inumeras informa√ß√µes a mais, e tanta informa√ß√£o assim, as vezes, deixa voc√™ meio L√©l√© da cuca, ent√£o busquei por projetos no&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    https://bl.ocks.org/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aconselho a todos irem l√° e desfrutarem de tantas cria√ß√µes legais e divertidas, que podemos usar em inumeros dados, da forma como quisermos, al√©m de ter todo o codigo aberto para entendermos a ideia.&lt;/p&gt;

&lt;p&gt;O fato √© que nessas pesquisas, encontrei esse link:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    https://bl.ocks.org/micahstubbs/3f439df92579c5bb2902fab15742ba87
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Foi aqui que minha dor de cabe√ßa passou, mas eu primeiro tive que entender como era necessario passar o json para o nosso amigo script jLouvain, e foi ai que as ideias viram, mas para n√£o dar rodeios e ir direto ao ponto, voces precisam atentar para as linhas do &amp;lsquo;vis.js&amp;rsquo;, onde se diz&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var nodeData = nodes.map(function (d) {return d.id});
    var linkData = links.map(function (d) {return {source: d.source, target: d.target,      weight: d.weight}; });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;isso era oque eu precisava, usar os dados que foram carregados, e filtra-los para usar apenas os dados em que o jLouvain ir√° utilizar, exatamente aqui;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var community = jLouvain()
        .nodes(nodeData)
        .edges(linkData);

    var result  = community();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mas, n√£o precisamos usar os dados filtrados na nossa visualiza√ß√£o, pois l√° possuem varios dados importantissimos para a leitura da mesma, como o Label, ent√£o usamos outra variavel para dessa forma, criar os circulos referentes aos n√≥s, e os links referentes as arestas da nossa visualiza√ß√£o, deixarei aqui a mudan√ßa que fiz para que os label fossem usados na nossa visualiza√ß√£o e pudessemos identificar quais artistas pertences aos clusters formados, clusters esses que se afastam um dos outros, √© lindo de se ver.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    circles.append(&amp;quot;title&amp;quot;)
        .text(function (d) { return d.label; });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bem, sei que voc√™s querem ver como ficou, ent√£o aqui est√°:&lt;/p&gt;

&lt;div id=&#34;chart&#34;&gt;&lt;/div&gt;

&lt;p&gt;Espero que tenham gostado, depois eu passo aqui e coloco mais alguma coisinha nova pra voc√™s, fiquem bem, se alimentem, e nunca esque√ßam de seus caf√©s, Certo ???&lt;/p&gt;

&lt;p&gt;Abs: L√©o. üòå&lt;/p&gt;

&lt;script src=&#39;//d3js.org/d3.v4.min.js&#39;&gt;&lt;/script&gt;

&lt;script&gt;
    /* global d3 */

d3.json(&#39;https://raw.githubusercontent.com/tsleolima/lab-redes/master/artistasSemelhantesNandoReis.json&#39;, (error, graph) =&gt; {
    if (error) throw error;
    const nodes = graph.nodes;
    const links = graph.edges;

    const width = 1000;
    const height = 1000;

    // separation between same-color circles
    const padding = 9; // 1.5

    // separation between different-color circles
    const clusterPadding = 48; // 6

    const maxRadius = 12;

    const z = d3.scaleOrdinal(d3.schemeCategory20);

    // total number of nodes
    const n = nodes.length;

    // detect communities with jsLouvain
    var nodeData = nodes.map(function (d) { return d.id });
    var linkData = links.map(function (d) { return { source: d.source, target: d.target }; });

    var community = jLouvain()
        .nodes(nodeData)
        .edges(linkData);

    var result = community();

    const defaultRadius = 8;
    nodes.forEach(function (node) {
        node.r = defaultRadius;
        node.cluster = result[node.id]
    });

    // collect clusters from nodes
    const clusters = {};
    nodes.forEach((node) =&gt; {
        const radius = node.r;
        const clusterID = node.cluster;
        if (!clusters[clusterID] || (radius &gt; clusters[clusterID].r)) {
            clusters[clusterID] = node;
        }
    });

    var svg = d3.select(&#34;#chart&#34;)
    .append(&#34;svg&#34;)
    .attr(&#39;version&#39;, &#39;1.1&#39;)
    .attr(&#39;viewBox&#39;, &#39;0 0 &#39; + width + &#39; &#39; + height)
    .attr(&#39;width&#39;, &#39;100%&#39;);

    let link = svg.selectAll(&#39;line&#39;)
        .data(graph.edges)
        .enter().append(&#39;line&#39;);

    link
        .attr(&#39;class&#39;, &#39;link&#39;)
        .style(&#39;stroke&#39;, &#39;darkgray&#39;)
        .style(&#39;stroke-width&#39;, &#39;0.2px&#39;);

    const circles = svg.append(&#39;g&#39;)
        .datum(nodes)
        .selectAll(&#39;.circle&#39;)
        .data(d =&gt; d)
        .enter().append(&#39;circle&#39;)
        .attr(&#39;r&#39;, d =&gt; d.r)
        .attr(&#39;fill&#39;, d =&gt; z(d.cluster))
        .attr(&#39;stroke&#39;, &#39;black&#39;)
        .attr(&#39;stroke-width&#39;, 1)
        .call(d3.drag()
            .on(&#34;start&#34;, dragstarted)
            .on(&#34;drag&#34;, dragged)
            .on(&#34;end&#34;, dragended)
        );

    circles.append(&#34;title&#34;)
        .text(function (d) { return d.label; });

    const simulation = d3.forceSimulation()
        .nodes(nodes)
        .force(&#39;link&#39;, d3.forceLink().id(d =&gt; d.id))
        .force(&#34;charge&#34;, d3.forceManyBody())
        .force(&#34;center&#34;, d3.forceCenter(width / 2, height / 2))
        // .velocityDecay(0.2)
        .force(&#39;x&#39;, d3.forceX().strength(0.0005))
        .force(&#39;y&#39;, d3.forceY().strength(0.0005))
        .force(&#39;collide&#39;, collide)
        .force(&#39;cluster&#39;, clustering)
        .on(&#39;tick&#39;, ticked);

    simulation.force(&#39;link&#39;)
        .links(graph.edges)
        // .distance([85]);

    function ticked() {
        link
            .attr(&#39;x1&#39;, d =&gt; d.source.x)
            .attr(&#39;y1&#39;, d =&gt; d.source.y)
            .attr(&#39;x2&#39;, d =&gt; d.target.x)
            .attr(&#39;y2&#39;, d =&gt; d.target.y);

        circles
            .attr(&#39;cx&#39;, d =&gt; d.x)
            .attr(&#39;cy&#39;, d =&gt; d.y);
    }

    function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
    }

    function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }

    // These are implementations of the custom forces
    function clustering(alpha) {
        nodes.forEach((d) =&gt; {
            const cluster = clusters[d.cluster];
            if (cluster === d) return;
            let x = d.x - cluster.x;
            let y = d.y - cluster.y;
            let l = Math.sqrt((x * x) + (y * y));
            const r = d.r + cluster.r;
            if (l !== r) {
                l = ((l - r) / l) * alpha;
                d.x -= x *= l;
                d.y -= y *= l;
                cluster.x += x;
                cluster.y += y;
            }
        });
    }

    function collide(alpha) {
        const quadtree = d3.quadtree()
            .x(d =&gt; d.x)
            .y(d =&gt; d.y)
            .addAll(nodes);

        nodes.forEach((d) =&gt; {
            const r = d.r + maxRadius + Math.max(padding, clusterPadding);
            const nx1 = d.x - r;
            const nx2 = d.x + r;
            const ny1 = d.y - r;
            const ny2 = d.y + r;
            quadtree.visit((quad, x1, y1, x2, y2) =&gt; {
                if (quad.data &amp;&amp; (quad.data !== d)) {
                    let x = d.x - quad.data.x;
                    let y = d.y - quad.data.y;
                    let l = Math.sqrt((x * x) + (y * y));
                    const r = d.r + quad.data.r + (d.cluster === quad.data.cluster ? padding : clusterPadding);
                    if (l &lt; r) {
                        l = ((l - r) / l) * alpha;
                        d.x -= x *= l;
                        d.y -= y *= l;
                        quad.data.x += x;
                        quad.data.y += y;
                    }
                }
                return x1 &gt; nx2 || x2 &lt; nx1 || y1 &gt; ny2 || y2 &lt; ny1;
            });
        });
    }
    

});
&lt;/script&gt;

&lt;script&gt;
    /*
Author: Corneliu S. (github.com/upphiminn)

This is a javascript implementation of the Louvain
community detection algorithm (http://arxiv.org/abs/0803.0476)
Based on https://bitbucket.org/taynaud/python-louvain/overview

*/
(function(){
    jLouvain = function(){
        //Constants
        var __PASS_MAX = -1
        var __MIN    = 0.0000001

        //Local vars
        var original_graph_nodes;
        var original_graph_edges;
        var original_graph = {};
        var partition_init;

        //Helpers
        function make_set(array){
            var set = {};
            array.forEach(function(d,i){
                set[d] = true;
            });
            return Object.keys(set);
        };

        function obj_values(obj){
             var vals = [];
             for( var key in obj ) {
                 if ( obj.hasOwnProperty(key) ) {
                     vals.push(obj[key]);
                 }
             }
             return vals;
        };

        function get_degree_for_node(graph, node){
            var neighbours = graph._assoc_mat[node] ? Object.keys(graph._assoc_mat[node]) : [];
            var weight = 0;
            neighbours.forEach(function(neighbour,i){
                var value = graph._assoc_mat[node][neighbour] || 1;
                if(node == neighbour)
                    value *= 2;
                weight += value;
            });
            return weight;
        };

        function get_neighbours_of_node(graph, node){
            if(typeof graph._assoc_mat[node] == &#39;undefined&#39;)
                return [];

            var neighbours = Object.keys(graph._assoc_mat[node]);
            return neighbours;
        }

        function get_edge_weight(graph, node1, node2){
            return graph._assoc_mat[node1] ? graph._assoc_mat[node1][node2] : undefined;
        }

        function get_graph_size(graph){
            var size = 0;
            graph.edges.forEach(function(edge){
                size += edge.weight;
            });
            return size;
        }

        function add_edge_to_graph(graph, edge){
            update_assoc_mat(graph, edge);

            var edge_index = graph.edges.map(function(d){
                return d.source+&#39;_&#39;+d.target;
            }).indexOf(edge.source+&#39;_&#39;+edge.target);

            if(edge_index != -1)
                graph.edges[edge_index].weight = edge.weight;
            else
                graph.edges.push(edge);
        }

        function make_assoc_mat(edge_list){
            var mat = {};
            edge_list.forEach(function(edge, i){
                mat[edge.source] = mat[edge.source] || {};
                mat[edge.source][edge.target] = edge.weight;
                mat[edge.target] = mat[edge.target] || {};
                mat[edge.target][edge.source] = edge.weight;
            });

            return mat;
        }

        function update_assoc_mat(graph, edge){
            graph._assoc_mat[edge.source] = graph._assoc_mat[edge.source] || {};
            graph._assoc_mat[edge.source][edge.target] = edge.weight;
            graph._assoc_mat[edge.target] = graph._assoc_mat[edge.target] || {};
            graph._assoc_mat[edge.target][edge.source] = edge.weight;
        }

        function clone(obj){
            if(obj == null || typeof(obj) != &#39;object&#39;)
                return obj;

            var temp = obj.constructor();

            for(var key in obj)
                temp[key] = clone(obj[key]);
            return temp;
        }

        //Core-Algorithm Related
        function init_status(graph, status, part){
            status[&#39;nodes_to_com&#39;] = {};
            status[&#39;total_weight&#39;] = 0;
            status[&#39;internals&#39;] = {};
            status[&#39;degrees&#39;] = {};
            status[&#39;gdegrees&#39;] = {};
            status[&#39;loops&#39;] = {};
            status[&#39;total_weight&#39;] = get_graph_size(graph);

            if(typeof part == &#39;undefined&#39;){
                graph.nodes.forEach(function(node,i){
                    status.nodes_to_com[node] = i;
                    var deg = get_degree_for_node(graph, node);
                    if (deg &lt; 0)
                        throw &#39;Bad graph type, use positive weights!&#39;;
                    status.degrees[i] = deg;
                    status.gdegrees[node] = deg;
                    status.loops[node] = get_edge_weight(graph, node, node) || 0;
                    status.internals[i] = status.loops[node];
                });
            }else{
                graph.nodes.forEach(function(node,i){
                    var com = part[node];
                    status.nodes_to_com[node] = com;
                    var deg = get_degree_for_node(graph, node);
                    status.degrees[com] = (status.degrees[com] || 0) + deg;
                    status.gdegrees[node] = deg;
                    var inc = 0.0;

                    var neighbours  = get_neighbours_of_node(graph, node);
                    neighbours.forEach(function(neighbour, i){
                        var weight = graph._assoc_mat[node][neighbour];
                        if (weight &lt;= 0){
                            throw &#34;Bad graph type, use positive weights&#34;;
                        }

                        if(part[neighbour] == com){
                            if (neighbour == node){
                                inc += weight;
                            }else{
                                inc += weight/2.0;
                            }
                        }
                    });
                    status.internals[com] = (status.internals[com] || 0) + inc;
                });
            }
        }

        function __modularity(status){
            var links = status.total_weight;
            var result = 0.0;
            var communities = make_set(obj_values(status.nodes_to_com));

            communities.forEach(function(com,i){
                var in_degree = status.internals[com] || 0 ;
                var degree = status.degrees[com] || 0 ;
                if(links &gt; 0){
                    result = result + in_degree / links - Math.pow((degree / (2.0*links)), 2);
                }
            });
            return result;
        }

        function __neighcom(node, graph, status){
            // compute the communities in the neighb. of the node, with the graph given by
            // node_to_com

            var weights = {};
            var neighboorhood = get_neighbours_of_node(graph, node);//make iterable;

            neighboorhood.forEach(function(neighbour, i){
                if(neighbour != node){
                    var weight = graph._assoc_mat[node][neighbour] || 1; 
                    var neighbourcom = status.nodes_to_com[neighbour];
                    weights[neighbourcom] = (weights[neighbourcom] || 0) + weight;
                }   
            });

            return weights;
        }

        function __insert(node, com, weight, status){
            //insert node into com and modify status
            status.nodes_to_com[node] = +com;
            status.degrees[com] = (status.degrees[com] || 0) + (status.gdegrees[node]||0);
            status.internals[com] = (status.internals[com] || 0) + weight + (status.loops[node]||0);
        }

        function __remove(node, com, weight, status){
            //remove node from com and modify status
            status.degrees[com] = ((status.degrees[com] || 0) - (status.gdegrees[node] || 0));
            status.internals[com] = ((status.internals[com] || 0) - weight -(status.loops[node] ||0));
            status.nodes_to_com[node] = -1;
        }

        function __renumber(dict){
            var count = 0;
            var ret = clone(dict); //deep copy :)
            var new_values = {};
            var dict_keys = Object.keys(dict);
            dict_keys.forEach(function(key){
                var value = dict[key];
                var new_value =  typeof new_values[value] ==&#39;undefined&#39; ? -1 : new_values[value];
                if(new_value == -1){
                    new_values[value] = count;
                    new_value = count;
                    count = count + 1;
                }
                ret[key] = new_value;
            });
            return ret;
        }

        function __one_level(graph, status){
            //Compute one level of the Communities Dendogram.
            var modif = true,
                nb_pass_done = 0,
                cur_mod = __modularity(status),
                new_mod = cur_mod;

            while (modif &amp;&amp; nb_pass_done != __PASS_MAX){
                cur_mod = new_mod;
                modif = false;
                nb_pass_done += 1

                graph.nodes.forEach(function(node,i){
                    var com_node = status.nodes_to_com[node];
                    var degc_totw = (status.gdegrees[node] || 0) / (status.total_weight * 2.0);
                    var neigh_communities = __neighcom(node, graph, status);
                    __remove(node, com_node, (neigh_communities[com_node] || 0.0), status);
                    var best_com = com_node;
                    var best_increase = 0;
                    var neigh_communities_entries = Object.keys(neigh_communities);//make iterable;

                    neigh_communities_entries.forEach(function(com,i){
                        var incr = neigh_communities[com] - (status.degrees[com] || 0.0) * degc_totw;
                        if (incr &gt; best_increase){
                            best_increase = incr;
                            best_com = com;
                        }
                    });

                    __insert(node, best_com, neigh_communities[best_com] || 0, status);

                    if(best_com != com_node)
                        modif = true;
                });
                new_mod = __modularity(status);
                if(new_mod - cur_mod &lt; __MIN)
                    break;
            }
        }

        function induced_graph(partition, graph){
            var ret = {nodes:[], edges:[], _assoc_mat: {}};
            var w_prec, weight;
            //add nodes from partition values
            var partition_values = obj_values(partition);
            ret.nodes = ret.nodes.concat(make_set(partition_values)); //make set
            graph.edges.forEach(function(edge,i){
                weight = edge.weight || 1;
                var com1 = partition[edge.source];
                var com2 = partition[edge.target];
                w_prec = (get_edge_weight(ret, com1, com2) || 0); 
                var new_weight = (w_prec + weight);
                add_edge_to_graph(ret, {&#39;source&#39;: com1, &#39;target&#39;: com2, &#39;weight&#39;: new_weight});
            });
            return ret;
        }

        function partition_at_level(dendogram, level){
            var partition = clone(dendogram[0]);
            for(var i = 1; i &lt; level + 1; i++ )
                Object.keys(partition).forEach(function(key,j){
                    var node = key;
                    var com  = partition[key];
                    partition[node] = dendogram[i][com];
                });
            return partition;
        }


        function generate_dendogram(graph, part_init){

            if(graph.edges.length == 0){
                var part = {};
                graph.nodes.forEach(function(node,i){
                    part[node] = node;
                });
                return part;
            }
            var status = {};

            init_status(original_graph, status, part_init);
            var mod = __modularity(status);
            var status_list = [];
            __one_level(original_graph, status);
            var new_mod = __modularity(status);
            var partition = __renumber(status.nodes_to_com);
            status_list.push(partition);
            mod = new_mod;
            var current_graph = induced_graph(partition, original_graph);
            init_status(current_graph, status);

            while (true){
                __one_level(current_graph, status);
                new_mod = __modularity(status);
                if(new_mod - mod &lt; __MIN)
                    break;

                partition = __renumber(status.nodes_to_com);
                status_list.push(partition); 

                mod = new_mod;
                current_graph = induced_graph(partition, current_graph);
                init_status(current_graph, status);
            }

            return status_list; 
        }

        var core = function(){
            var status = {};
            var dendogram = generate_dendogram(original_graph, partition_init);
            return partition_at_level(dendogram, dendogram.length - 1);
        };

        core.nodes = function(nds){
            if(arguments.length &gt; 0){
                original_graph_nodes = nds;
            }
            return core;
        };

        core.edges = function(edgs){
            if(typeof original_graph_nodes == &#39;undefined&#39;)
                throw &#39;Please provide the graph nodes first!&#39;;

            if(arguments.length &gt; 0){
                original_graph_edges = edgs;
                var assoc_mat = make_assoc_mat(edgs);
                original_graph = { &#39;nodes&#39;: original_graph_nodes,
                                   &#39;edges&#39;: original_graph_edges,
                                   &#39;_assoc_mat&#39;: assoc_mat };
            }
            return core;

        };

        core.partition_init = function(prttn){
            if(arguments.length &gt; 0){
                partition_init = prttn;
            }
            return core;
        };

        return core;
    }
})();

&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>Visualiza√ß√£o de Dados com Intera√ß√£o</title>
      <link>https://tsleolima.github.io/portfolio-vis/post/visuinteracao/</link>
      <pubDate>Fri, 22 Dec 2017 17:21:06 -0300</pubDate>
      
      <guid>https://tsleolima.github.io/portfolio-vis/post/visuinteracao/</guid>
      <description>&lt;script src=&#34;https://d3js.org/d3.v4.min.js&#34;&gt;&lt;/script&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css&#34;&gt;
&lt;div class=&#34;container&#34;&gt;
&lt;div class=&#34;row&#34;&gt;
&lt;div class=&#34;col-md-8&#34;&gt;
&lt;h2&gt;Uma visualiza√ß√£o sobre o Bobs com intera√ß√£o&lt;/h2&gt;

&lt;div class=&#34;col-md-12&#34;&gt;&lt;p&gt;Como foi abordado no outro post sobre a visualiza√ß√£o do bobs, com os dados obtidos do em torno do a√ßude velho em Campina Grande, Paraiba, vemos aqui uma nova visualiza√ß√£o, olhando bem aparenta ser a mesma utilizada anteriormente, mas esta possui algumas intera√ß√µes com o usuario, na qual tem uma finalidade de se extrair o dado com mais facilidade, ou flexibilidade.&lt;/p&gt;

&lt;p&gt;Vamos para o gr√°fico, nessa nova vers√£o do line chart, temos alguns bot√µes e eventos com hover, ou seja, ao passarmos o mouse por cima das bolinhas que est√£o presentes na linha, vemos com detalhes a m√©dia dos pedestres que passavam no local naquele horario, mas, porque fazer isso, j√° que possuimos o eixo Y para nos retornar esse resultado ? Bem, a explica√ß√£o √© simples, dessa maneira vemos com precis√£o a m√©dia e com mais facilidade, obviamente poderiamos colocar mais informa√ß√µes usando essa ferramenta (hover) t√£o importante, mas eu tive apenas essa no momento :(&lt;/p&gt;

&lt;p&gt;Explicado como funcionam as bolinhas na nossa linha, vamos para os lindos bot√µes azuis, neles podemos trocar os dados, ou mesmo, visualizar a nova linha para um novo local, tamb√©m proximo do a√ßudo velho, para ver em qual local, por exemplo,o tr√°fego de pessoas √© maior naquele horario, enfim, existem n observa√ß√µes que podem ser feitas a partir desses dados, inclusive, retomando a ideia do marketing receber esses dados e aplicar em novas t√°ticas de merchandising naquele horario √© uma boa ideia!.&lt;/p&gt;
&lt;h3&gt;&lt;p&gt;Espero que gostem!!!&lt;/p&gt;&lt;/h3&gt;  &lt;/div&gt;

&lt;div class=&#34;row mychart&#34; id=&#34;chart&#34;&gt;&lt;/div&gt;


&lt;div id=&#34;controls&#34;&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&#34;tooltip&#34; class=&#34;hidden&#34;&gt;
  &lt;p id=&#34;titulo_tooltip&#34;&gt; &lt;/p&gt;
  &lt;p&gt; &lt;b id=&#34;value&#34;&gt;0&lt;/b&gt; &lt;/p&gt;
&lt;/div&gt;

&lt;style type=&#34;text/css&#34;&gt;

  .line {
    fill: none;
    stroke: #ffba49;
    stroke-width: 3;
  }

  input{
    margin-left: 60px;
  }

  .dot {
    fill: #20a39e;
    stroke: #fff;
  }

  rect {
    fill: steelblue;
  }

  rect:hover {
    fill: red;
  }

  text {
    font: 12px sans-serif;
    text-anchor: left;
  }

  .row p{
    padding: 10px;
  }

  #tooltip {
    position: absolute;
    width: auto;
    height: auto;
    padding: 10px;
    background-color: #23001e;
    border-radius: 10px;
    box-shadow:5px 10px 18px #888888;
}

  #controls {
    position: absolute;
    width: auto;
    height: auto;
}

  #tooltip.hidden {
    display: none;
}

  #tooltip p {
    margin: 0;
    font-family: sans-serif;
    font-size: 12px;
    line-height: 20px;
    color: #fff;
    text-align: center;
}

&lt;/style&gt;

&lt;script type=&#34;text/javascript&#34;&gt;
&#34;user strict&#34;

function desenhaVisualizacaoLinha(dados){

  var horariosBobs = dados.filter((dado) =&gt; dado.local === &#34;bobs&#34;);

  var margin = {top: 50, right: 50, bottom: 50, left: 50}
  , width = 1000 - margin.left - margin.right
  , height = 500 - margin.top - margin.bottom;

  mediaBobs = fazMedia(horariosBobs);

  var xScale = d3.scaleBand()
  .domain(mediaBobs.map((dado,indice) =&gt; dado.horas))
  .range([0, width])
  .padding([1]);

  var yScale = d3.scaleLinear()
  .domain([0, 320])
  .rangeRound([height, 0]);

  var line = d3.line()
  .x(function(d, i) { return xScale(d.horas); })
  .y(function(d) { return yScale(d.media); })
  .curve(d3.curveMonotoneX);

  var svg = d3.select(&#34;#chart&#34;).append(&#34;svg&#34;)
  .attr(&#34;width&#34;, width + margin.left + margin.right)
  .attr(&#34;height&#34;, height + margin.top + margin.bottom)
  .append(&#34;g&#34;)
  .attr(&#34;transform&#34;, &#34;translate(&#34; + margin.left + &#34;,&#34; + margin.top + &#34;)&#34;);

  svg.append(&#34;g&#34;)
  .attr(&#34;class&#34;, &#34;x axis&#34;)
  .attr(&#34;transform&#34;, &#34;translate(0,&#34; + height + &#34;)&#34;)
  .call(d3.axisBottom(xScale))

  svg.append(&#34;g&#34;)
  .attr(&#34;class&#34;, &#34;y axis&#34;)
  .call(d3.axisLeft(yScale));

  svg.append(&#34;path&#34;)
  .datum(mediaBobs)
  .attr(&#34;class&#34;, &#34;line&#34;)
  .attr(&#34;d&#34;, line);


  svg.selectAll(&#34;.dot&#34;)
  .data(mediaBobs)
  .enter().append(&#34;circle&#34;) // Uses the enter().append() method
  .attr(&#34;class&#34;, &#34;dot&#34;) // Assign a class for styling
  .attr(&#34;cx&#34;, function(d, i) { return xScale(d.horas) })
  .attr(&#34;cy&#34;, function(d) { return yScale(d.media) })
  .attr(&#34;r&#34;, 5);

  svg.selectAll(&#34;.dot&#34;).on(&#34;mouseover&#34;, mouseDentro);
  function mouseDentro(d){

    d3.select(&#34;#tooltip&#34;) // reparou que tem uma div escondida no html?
    .style(&#34;left&#34;, (d3.event.pageX + 50) + &#34;px&#34;)
    .style(&#34;top&#34;, (d3.event.pageY - 60) + &#34;px&#34;)
    .select(&#34;#value&#34;)
    .text(d.media);
    d3.select(&#34;#tooltip #titulo_tooltip&#34;)
    .text(&#34;M√©dia de pedestres&#34;)
    // Mostra o tooltip
    d3.select(&#34;#tooltip&#34;).classed(&#34;hidden&#34;, false);
  }

  svg.selectAll(&#34;.dot&#34;).on(&#34;mouseout&#34;, mouseSaiu);
  function mouseSaiu(d){
    // n√£o precisamos mais de tooltip
    d3.select(&#34;#tooltip&#34;).classed(&#34;hidden&#34;, true);
  }

  // Os Bot√µes

  d3.select(&#34;#controls&#34;)
  .append(&#34;input&#34;)
  .attr(&#34;type&#34;,&#34;button&#34;)
  .attr(&#34;value&#34;,&#34;M√©dia Bobs&#34;)
  .attr(&#34;class&#34;, &#34;btn btn-primary&#34;)
  .on(&#34;click&#34;, mudaHorarioBobs)

  d3.select(&#34;#controls&#34;)
  .append(&#34;input&#34;)
  .attr(&#34;type&#34;,&#34;button&#34;)
  .attr(&#34;value&#34;,&#34;M√©dia Jackson&#34;)
  .attr(&#34;class&#34;, &#34;btn btn-primary&#34;)
  .on(&#34;click&#34;, mudaHorarioJackson)

  d3.select(&#34;#controls&#34;)
  .append(&#34;input&#34;)
  .attr(&#34;type&#34;,&#34;button&#34;)
  .attr(&#34;value&#34;,&#34;M√©dia Burrinhos&#34;)
  .attr(&#34;class&#34;, &#34;btn btn-primary&#34;)
  .on(&#34;click&#34;, mudaHorarioBurrinhos)


  function mudaHorarioBobs(){
    var horariosBobs = dados.filter((dado) =&gt; dado.local === &#34;bobs&#34;);
    var mediaBobs = fazMedia(horariosBobs);

    svg.select(&#34;.line&#34;)
    .datum(mediaBobs)
    .attr(&#34;class&#34;, &#34;line&#34;)
    .attr(&#34;d&#34;, line)

    svg.selectAll(&#34;circle&#34;).remove()

    svg.selectAll(&#34;circle&#34;)
    .data(mediaBobs)
    .enter().append(&#34;circle&#34;) // Uses the enter().append() method
    .attr(&#34;class&#34;, &#34;dot&#34;) // Assign a class for styling
    .attr(&#34;cx&#34;, function(d, i) { return xScale(d.horas) })
    .attr(&#34;cy&#34;, function(d) { return yScale(d.media) })
    .attr(&#34;r&#34;, 5);

    svg.selectAll(&#34;.dot&#34;).on(&#34;mouseover&#34;, mouseDentro);
    function mouseDentro(d){

      d3.select(&#34;#tooltip&#34;) // reparou que tem uma div escondida no html?
      .style(&#34;left&#34;, (d3.event.pageX + 50) + &#34;px&#34;)
      .style(&#34;top&#34;, (d3.event.pageY - 60) + &#34;px&#34;)
      .select(&#34;#value&#34;)
      .text(d.media);
      d3.select(&#34;#tooltip #titulo_tooltip&#34;)
      .text(&#34;M√©dia de pedestres&#34;)
      // Mostra o tooltip
      d3.select(&#34;#tooltip&#34;).classed(&#34;hidden&#34;, false);
    }

    svg.selectAll(&#34;.dot&#34;).on(&#34;mouseout&#34;, mouseSaiu);
    function mouseSaiu(d){
      // n√£o precisamos mais de tooltip
      d3.select(&#34;#tooltip&#34;).classed(&#34;hidden&#34;, true);
    }

  }

  function mudaHorarioJackson(){
    var horariosJackson = dados.filter((dado) =&gt; dado.local === &#34;jackson&#34;);
    var mediaJackson = fazMedia(horariosJackson);

    svg.select(&#34;.line&#34;)
    .datum(mediaJackson)
    .attr(&#34;class&#34;, &#34;line&#34;)
    .attr(&#34;d&#34;, line)

    svg.selectAll(&#34;circle&#34;).remove()

    svg.selectAll(&#34;circle&#34;)
    .data(mediaJackson)
    .enter().append(&#34;circle&#34;) // Uses the enter().append() method
    .attr(&#34;class&#34;, &#34;dot&#34;) // Assign a class for styling
    .attr(&#34;cx&#34;, function(d, i) { return xScale(d.horas) })
    .attr(&#34;cy&#34;, function(d) { return yScale(d.media) })
    .attr(&#34;r&#34;, 5);

    svg.selectAll(&#34;.dot&#34;).on(&#34;mouseover&#34;, mouseDentro);
    function mouseDentro(d){

      d3.select(&#34;#tooltip&#34;) // reparou que tem uma div escondida no html?
      .style(&#34;left&#34;, (d3.event.pageX + 50) + &#34;px&#34;)
      .style(&#34;top&#34;, (d3.event.pageY - 60) + &#34;px&#34;)
      .select(&#34;#value&#34;)
      .text(d.media);
      d3.select(&#34;#tooltip #titulo_tooltip&#34;)
      .text(&#34;M√©dia de pedestres&#34;)
      // Mostra o tooltip
      d3.select(&#34;#tooltip&#34;).classed(&#34;hidden&#34;, false);
    }

    svg.selectAll(&#34;.dot&#34;).on(&#34;mouseout&#34;, mouseSaiu);
    function mouseSaiu(d){
      // n√£o precisamos mais de tooltip
      d3.select(&#34;#tooltip&#34;).classed(&#34;hidden&#34;, true);
    }

  }

  function mudaHorarioBurrinhos(){
    var horariosBurrinhos = dados.filter((dado) =&gt; dado.local === &#34;burrinhos&#34;);
    var mediaBurrinhos = fazMedia(horariosBurrinhos);

    svg.select(&#34;.line&#34;)
    .datum(mediaBurrinhos)
    .attr(&#34;class&#34;, &#34;line&#34;)
    .attr(&#34;d&#34;, line)

    svg.selectAll(&#34;circle&#34;).remove()

    svg.selectAll(&#34;circle&#34;)
    .data(mediaBurrinhos)
    .enter().append(&#34;circle&#34;) // Uses the enter().append() method
    .attr(&#34;class&#34;, &#34;dot&#34;) // Assign a class for styling
    .attr(&#34;cx&#34;, function(d, i) { return xScale(d.horas) })
    .attr(&#34;cy&#34;, function(d) { return yScale(d.media) })
    .attr(&#34;r&#34;, 5);

    svg.selectAll(&#34;.dot&#34;).on(&#34;mouseover&#34;, mouseDentro);
    function mouseDentro(d){

      d3.select(&#34;#tooltip&#34;) // reparou que tem uma div escondida no html?
      .style(&#34;left&#34;, (d3.event.pageX + 50) + &#34;px&#34;)
      .style(&#34;top&#34;, (d3.event.pageY - 60) + &#34;px&#34;)
      .select(&#34;#value&#34;)
      .text(d.media);
      d3.select(&#34;#tooltip #titulo_tooltip&#34;)
      .text(&#34;M√©dia de pedestres&#34;)
      // Mostra o tooltip
      d3.select(&#34;#tooltip&#34;).classed(&#34;hidden&#34;, false);
    }

    svg.selectAll(&#34;.dot&#34;).on(&#34;mouseout&#34;, mouseSaiu);
    function mouseSaiu(d){
      // n√£o precisamos mais de tooltip
      d3.select(&#34;#tooltip&#34;).classed(&#34;hidden&#34;, true);
    }

  }

}
d3.csv(&#34;https://raw.githubusercontent.com/luizaugustomm/pessoas-no-acude/master/dados/processados/dados.csv&#34;,function(dados){
  desenhaVisualizacaoLinha(dados);
  });

  function fazMedia(dados){

    var horas = [&#34;6:00&#34;,&#34;7:00&#34;,&#34;8:00&#34;,&#34;9:00&#34;,&#34;10:00&#34;,&#34;11:00&#34;,&#34;12:00&#34;,&#34;13:00&#34;,&#34;14:00&#34;,&#34;15:00&#34;,&#34;16:00&#34;,&#34;17:00&#34;,&#34;18:00&#34;,&#34;19:00&#34;,&#34;20:00&#34;];
    var cont = 0;
    var soma = 0;
    var indice = 0;
    var mediaHoras = [];
    for (var i = 0; i &lt; dados.length; i++) {
      if(cont == 4){
        var media = soma / cont;
        var objeto = {&#39;horas&#39;:horas[indice],media:media};
        mediaHoras[indice] = objeto;
        cont = 0;
        soma = 0;
        indice ++;
      }
      soma += parseInt(dados[i].total_pedestres);
      cont ++;
    }
    return mediaHoras;
  }

  &lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>Visualiza√ß√£o de dados sobre o Bobs</title>
      <link>https://tsleolima.github.io/portfolio-vis/post/lab-4/</link>
      <pubDate>Sun, 10 Dec 2017 16:55:39 -0300</pubDate>
      
      <guid>https://tsleolima.github.io/portfolio-vis/post/lab-4/</guid>
      <description>&lt;script src=&#34;https://d3js.org/d3.v4.min.js&#34;&gt;&lt;/script&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css&#34;&gt;
&lt;div class=&#34;container&#34;&gt;
&lt;div class=&#34;row&#34;&gt;
&lt;h2&gt;Uma visualiza√ß√£o sobre o Bobs&lt;/h2&gt;
&lt;p&gt;Dessa vez, estou trazendo um visualiza√ß√£o um pouco diferente das convencionais (Barras),a ideia √© usar um gr√°fico linear,&lt;br&gt; ou tamb√©m conhecido como line chart, para representar a grande quantidade de dados massivos, obtidos no entorno do a√ßude velho,&lt;br&gt; situado em Campina Grande,Paraiba, afim de mostrar ao utilizadores dos servi√ßos do Bobs, ou at√© mesmo do sistema de marketing da empresa,&lt;br&gt; os picos de horarios em que o local √© mais frequentado.&lt;/p&gt;

&lt;p&gt;No gr√°fico a seguir, foram utilizados o n√∫mero de pedestres que passavam perto do Bobs, e ent√£o √© feita um mapeamento do horario para a quantidade &lt;br&gt; de pessoas naquele horario.&lt;/p&gt;

&lt;div class=&#34;row mychart&#34; id=&#34;chart&#34;&gt;&lt;/div&gt;

&lt;p&gt;Podemos observar que o horario em que mais pessoas trafegam proximo ao Bobs √© entorno de 17:00 e 19:30, caso essa pesquisa chegue &lt;br&gt; ao ouvidos do marketing do Bobs, pode ser feita alguma estrategia para atrair todas essa pessoas para o local, ou ate mesmo investir em horarios&lt;br&gt; ou refei√ß√µes em que existe um pessoal relativamente menor que o mencionado, enfim, cabe ao marketing resolver.

&lt;p&gt;Nessa pr√≥xima visualiza√ß√£o, temos um gr√°fico em barras nele vemos outro modo de visualizar os mesmos dados, mas dessa vez&lt;br&gt; temos a m√©dia dos pedestres em cada hora, sendo assim, existe uma facilidade em ver qual hora possui uma m√©dia maior.

&lt;div class=&#34;row mychart&#34; id=&#34;chart2&#34;&gt;&lt;/div&gt;

&lt;p&gt;Aqui, retornamos com o mesmo gr√°fico de linhas, mas dessa vez um pouco mais refinado, e se puderem observar atentamente,vemos &lt;br&gt; que as linhas tamb√©m est√£o sendo moduladas atraves de m√©dias de cada horario, ou seja, podemos generalizar qual horario realmente √© mais &lt;br&gt; movimentado, ao contrario do anterior que seria apenas no intervalo de tempo de 15 em 15 minutos.

&lt;div class=&#34;row mychart&#34; id=&#34;chart3&#34;&gt;&lt;/div&gt;

&lt;script type=&#34;text/javascript&#34;&gt;
&#34;user strict&#34;

function desenhaVisualizacaoLinha(dados){

  var horariosBobs = dados.filter((dado) =&gt; dado.local === &#34;bobs&#34;);

  var margin = {top: 50, right: 50, bottom: 50, left: 50}
  , width = 1000 - margin.left - margin.right
  , height = 500 - margin.top - margin.bottom;

  mediaBobs = fazMedia(horariosBobs);

  var xScale = d3.scaleBand()
  .domain(mediaBobs.map((dado,indice) =&gt; dado.horas))
  .range([0, width])
  .padding([1]);

  var yScale = d3.scaleLinear()
  .domain([0, 320])
  .rangeRound([height, 0]);

  var line = d3.line()
  .x(function(d, i) { return xScale(d.horas); })
  .y(function(d) { return yScale(d.media); })
  .curve(d3.curveMonotoneX);

  var svg = d3.select(&#34;#chart3&#34;).append(&#34;svg&#34;)
  .attr(&#34;width&#34;, width + margin.left + margin.right)
  .attr(&#34;height&#34;, height + margin.top + margin.bottom)
  .append(&#34;g&#34;)
  .attr(&#34;transform&#34;, &#34;translate(&#34; + margin.left + &#34;,&#34; + margin.top + &#34;)&#34;);

  svg.append(&#34;g&#34;)
  .attr(&#34;class&#34;, &#34;x axis&#34;)
  .attr(&#34;transform&#34;, &#34;translate(0,&#34; + height + &#34;)&#34;)
  .call(d3.axisBottom(xScale))

  svg.append(&#34;g&#34;)
  .attr(&#34;class&#34;, &#34;y axis&#34;)
  .call(d3.axisLeft(yScale));

  svg.append(&#34;path&#34;)
  .datum(mediaBobs)
  .attr(&#34;class&#34;, &#34;line&#34;)
  .attr(&#34;d&#34;, line);

}

function desenhaVisualizacaoBarras(dados){

  var horariosBobs = dados.filter((dado) =&gt; dado.local === &#34;bobs&#34;);

  var mediaBobs = fazMedia(horariosBobs);

  var alturaSVG = 550, larguraSVG = 900;
  var   margin = {top: 10, right: 20, bottom:30, left: 45},
  larguraVis = larguraSVG - margin.left - margin.right,
  alturaVis = alturaSVG - margin.top - margin.bottom;

  var grafico = d3.select(&#39;#chart2&#39;)
  .append(&#39;svg&#39;)
  .attr(&#39;width&#39;, larguraVis + margin.left + margin.right)
  .attr(&#39;height&#39;, alturaVis + margin.top + margin.bottom)
  .append(&#39;g&#39;)
  .attr(&#39;transform&#39;, &#39;translate(&#39; +  margin.left + &#39;,&#39; + margin.top + &#39;)&#39;);


  var x = d3.scaleBand()
  .domain(mediaBobs.map((dado, indice) =&gt; dado.horas))
  .range([0,larguraVis])
  .padding([0.5]);

  var y = d3.scaleLinear()
  .domain([0,250])
  .range([alturaVis,0]);

  grafico.selectAll(&#39;g&#39;)
  .data(mediaBobs)
  .enter()
  .append(&#39;rect&#39;)
  .attr(&#39;x&#39;, d =&gt; x(d.horas))
  .attr(&#39;y&#39;, d =&gt; y(d.media))
  .attr(&#39;width&#39;, x.bandwidth())
  .attr(&#39;height&#39;, (d) =&gt; alturaVis - y(d.media));


  grafico.append(&#34;g&#34;)
  .attr(&#34;class&#34;, &#34;x axis&#34;)
  .attr(&#34;transform&#34;, &#34;translate(0,&#34; + alturaVis + &#34;)&#34;)
  .call(d3.axisBottom(x));

  grafico.append(&#39;g&#39;)
  .attr(&#39;transform&#39;, &#39;translate(0,0)&#39;)
  .call(d3.axisLeft(y))

  grafico.append(&#34;text&#34;)
  .attr(&#34;transform&#34;, &#34;translate(10,&#34; + (alturaVis + margin.top)/4 + &#34;) rotate(0)&#34;)
  .text(&#34;M√©dia de pedestres&#34;);
}

function desenhaVisualizacao(dados){

var larguraSVG = 800,
alturaSVG = 500;

var horariosBobs = dados.filter((dado) =&gt; dado.local === &#34;bobs&#34;);
console.log(horariosBobs);

var margin = {top: 50, right: 50, bottom: 50, left: 50}
, width = larguraSVG - margin.left - margin.right
, height = alturaSVG - margin.top - margin.bottom;

var n = 59;
var horas = [&#34;6:00&#34;,&#34;7:00&#34;,&#34;8:00&#34;,&#34;9:00&#34;,&#34;10:00&#34;,&#34;11:00&#34;,&#34;12:00&#34;,&#34;13:00&#34;,&#34;14:00&#34;,&#34;15:00&#34;,&#34;16:00&#34;,&#34;17:00&#34;,&#34;18:00&#34;,&#34;19:00&#34;,&#34;20:00&#34;];

var xScale = d3.scaleLinear()
.domain([0, n])
.range([0, width]);

var x = d3.scaleBand()
.domain(horas)
.range([0, width]);

var yScale = d3.scaleLinear()
.domain([0, 320])
.range([height, 0]);

var line = d3.line()
.x(function(d, i) { return xScale(i); })
.y(function(d) { return yScale(d.total_pedestres); })
.curve(d3.curveMonotoneX);

var svg = d3.select(&#34;#chart&#34;).append(&#34;svg&#34;)
.attr(&#34;width&#34;, width + margin.left + margin.right)
.attr(&#34;height&#34;, height + margin.top + margin.bottom)
.append(&#34;g&#34;)
.attr(&#34;transform&#34;, &#34;translate(&#34; + margin.left + &#34;,&#34; + margin.top + &#34;)&#34;);

svg.append(&#34;g&#34;)
.attr(&#34;class&#34;, &#34;x axis&#34;)
.attr(&#34;transform&#34;, &#34;translate(-22,&#34; + height + &#34;)&#34;)
.call(d3.axisBottom(x))
.select(&#34;.domain&#34;)
.remove();

svg.append(&#34;g&#34;)
.attr(&#34;class&#34;, &#34;y axis&#34;)
.call(d3.axisLeft(yScale));

svg.append(&#34;path&#34;)
.datum(horariosBobs)
.attr(&#34;class&#34;, &#34;line&#34;)
.attr(&#34;d&#34;, line);

svg.append(&#34;text&#34;)
.attr(&#34;transform&#34;, &#34;translate(20,&#34; + (height/100) + &#34;) rotate(0)&#34;)
.text(&#34;N√∫mero de pedestres&#34;);

}

d3.csv(&#34;https://raw.githubusercontent.com/luizaugustomm/pessoas-no-acude/master/dados/processados/dados.csv&#34;,function(dados){
  desenhaVisualizacaoBarras(dados);
  desenhaVisualizacaoLinha(dados);
  desenhaVisualizacao(dados);
});

function fazMedia(dados){

  var horas = [&#34;6:00&#34;,&#34;7:00&#34;,&#34;8:00&#34;,&#34;9:00&#34;,&#34;10:00&#34;,&#34;11:00&#34;,&#34;12:00&#34;,&#34;13:00&#34;,&#34;14:00&#34;,&#34;15:00&#34;,&#34;16:00&#34;,&#34;17:00&#34;,&#34;18:00&#34;,&#34;19:00&#34;,&#34;20:00&#34;];
  var cont = 0;
  var soma = 0;
  var indice = 0;
  var mediaHoras = [];
  for (var i = 0; i &lt; dados.length; i++) {
    if(cont == 4){
      var media = soma / cont;
      var objeto = {&#39;horas&#39;:horas[indice],media:media};
      mediaHoras[indice] = objeto;
      cont = 0;
      soma = 0;
      indice ++;
    }
    soma += parseInt(dados[i].total_pedestres);
    cont ++;
  }
  return mediaHoras;
}

&lt;/script&gt;

&lt;style type=&#34;text/css&#34;&gt;
.line {
  fill: none;
  stroke: #ffab00;
  stroke-width: 3;
}

.dot {
  fill: #ffab00;
  stroke: #fff;
}

rect {
  fill: steelblue;
}

rect:hover {
  fill: red;
}

text {
  font: 12px sans-serif;
  text-anchor: left;
}

.row p{
  padding: 10px;
}

&lt;/style&gt;
</description>
    </item>
    
    <item>
      <title>Visualiza√ß√£o usando D3</title>
      <link>https://tsleolima.github.io/portfolio-vis/post/viz-d3/</link>
      <pubDate>Wed, 29 Nov 2017 14:40:02 -0300</pubDate>
      
      <guid>https://tsleolima.github.io/portfolio-vis/post/viz-d3/</guid>
      <description>&lt;script src=&#34;https://d3js.org/d3.v4.min.js&#34;&gt;&lt;/script&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css&#34;&gt;
&lt;div class=&#34;container&#34;&gt;
  &lt;div class=&#34;row&#34;&gt;
    &lt;h2&gt;Visualiza√ß√£o usando D3&lt;/h2&gt;
    &lt;p&gt;Aplicando elementos visuais para cria√ß√£o de uma visualiza√ß√£o apartir dos dados do a√ßude Epit√°cio Pessoa&lt;/p&gt;
  &lt;/div&gt;
  &lt;div class=&#34;row mychart&#34; id=&#34;chart&#34;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;style&gt;
  .mychart rect {
    fill: steelblue;
  }

  .mychart rect:hover {
    fill: red;
  }

  .mychart text {
    font: 12px sans-serif;
    text-anchor: left;
  }
&lt;/style&gt;

&lt;script type=&#34;text/javascript&#34;&gt;
  &#34;use strict&#34;

  function desenhaBarras(dados) {

    var larguraSVG = 700,
        alturaSVG = 200;

    var margin = {top: 50, right: 0, bottom: 50, left: 0}, // para descolar a vis das bordas do grafico
            larguraVis = larguraSVG - margin.left - margin.right,
            alturaVis = alturaSVG - margin.top - margin.bottom;

    var x = d3.scaleBand()
            .domain(dados.map((dado) =&gt; dado.mes))
            .range([0,larguraVis])
            .padding([1]);

    var grafico = d3.select(&#39;#chart&#39;)
      .append(&#39;svg&#39;)
        .attr(&#39;width&#39;,larguraSVG)
        .attr(&#39;height&#39;,alturaSVG)
        .append(&#39;g&#39;)
          .attr(&#39;transform&#39;, &#39;translate(&#39; + margin.left + &#39;,&#39; + margin.top + &#39;)&#39;);

    &lt;!-- O circulo amarelo indica os dados em noventa_percentil --&gt;

    grafico.selectAll(&#39;g&#39;)
      .data(dados)
      .enter()
        .append(&#39;circle&#39;)
          .attr(&#39;cx&#39;,dado =&gt; x(dado.mes))
          .attr(&#39;cy&#39;,50)
          .attr(&#39;r&#39;,dado =&gt; dado.noventa_percentil/4)
          .attr(&#34;fill&#34;,&#39;yellow&#39;);

    &lt;!-- O circulo em azul indica os dados em dez_percentil --&gt;

    grafico.selectAll(&#39;g&#39;)
      .data(dados)
      .enter()
        .append(&#39;circle&#39;)
          .attr(&#39;cx&#39;,dado =&gt; x(dado.mes))
          .attr(&#39;cy&#39;,50)
          .attr(&#39;r&#39;, dado =&gt; dado.dez_percentil/4)
          .attr(&#34;fill&#34;,&#39;blue&#39;);

    grafico.append(&#34;g&#34;)
      .attr(&#34;class&#34;, &#34;x axis&#34;)
      .attr(&#34;transform&#34;, &#34;translate(0,&#34; + alturaVis + &#34;)&#34;)
      .call(d3.axisBottom(x)); // magica do d3: gera eixo a partir da escala

  }

  d3.csv(&#39;https://raw.githubusercontent.com/tsleolima/intro-d3/master/dados/boqueirao-por-mes.csv&#39;, function(dados) {
    desenhaBarras(dados);
  });

&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>Minhas primeiras visualiza√ß√µes</title>
      <link>https://tsleolima.github.io/portfolio-vis/post/visualizacoesboqueirao/</link>
      <pubDate>Wed, 20 Apr 2016 00:00:00 -0300</pubDate>
      
      <guid>https://tsleolima.github.io/portfolio-vis/post/visualizacoesboqueirao/</guid>
      <description>

&lt;h1 id=&#34;como-tudo-come√ßou&#34;&gt;Como tudo come√ßou&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Primeiro de tudo, eu sou p√©ssimo com ideias de visualiza√ß√µes de Dados ( isso foi para ser engra√ßado).&lt;/li&gt;
&lt;li&gt;Esse √© um laboratorio para universidade e quem sabe alguem aproveite esses dados em um futuro.&lt;/li&gt;
&lt;li&gt;Minha miss√£o √© passar para voc√™s algumas situa√ß√µes que enfrentamos no decorrer dos anos com o a√ßude Epit√°cio Pessoa.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#como-tudo-come√ßou&#34;&gt;Como tudo come√ßou&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#historia-sobre-o-a√ßude-epit√°cio-pessoa&#34;&gt;Historia sobre o a√ßude Epit√°cio Pessoa.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bom-vamos-ao-que-interessa&#34;&gt;Bom vamos ao que interessa ?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/nav&gt;


&lt;h2 id=&#34;historia-sobre-o-a√ßude-epit√°cio-pessoa&#34;&gt;Historia sobre o a√ßude Epit√°cio Pessoa.&lt;/h2&gt;

&lt;p&gt;O A√ßude Epit√°cio Pessoa, popularmente conhecido como Boqueir√£o, √© uma represa localizada no munic√≠pio de Boqueir√£o, estado brasileiro da Para√≠ba. Sua bacia se estende pelos munic√≠pios de Boqueir√£o, Cabaceiras e S√£o Miguel de Taipu e abastece as cidades paraibanas de Campina Grande, Boqueir√£o, Queimadas, Pocinhos, Caturit√©, Riacho de Santo Ant√¥nio e Barra de S√£o Miguel.&lt;/p&gt;

&lt;p&gt;O a√ßude, que est√° situado na sub-bacia hidrogr√°fica do Alto Para√≠ba, que juntamente com as sub-bacias do rio Tapero√° e do M√©dio e Baixo Para√≠ba constituem a bacia hidrogr√°fica do rio Para√≠ba, abrange uma √°rea de 19.088,5 km¬≤, o que corresponde a 34% do territ√≥rio paraibano. Os 78 munic√≠pios inseridos nela abrigam uma popula√ß√£o em torno de 1,8 milh√£o de habitantes, aproximadamente, 55% da popula√ß√£o total do estado. Essas duas sub-bacias hidrogr√°ficas est√£o situadas em uma √°rea de baixa pluviosidade, com m√©dias anuais inferiores a 600 mm.&lt;/p&gt;

&lt;p&gt;Um estudo desenvolvido no in√≠cio dos anos 2000 pela Companhia de √Ågua e Esgotos da Para√≠ba (Cagepa) revelou que o volume h√≠drico acumulado no a√ßude sofreu uma redu√ß√£o de 67,27% nos √∫ltimos 20 anos. Na √©poca de sua constru√ß√£o, a capacidade de armazenamento do a√ßude inicialmente era de 536 milh√µes de metros c√∫bicos, mas com o assoreamento essa capacidade foi reduzida para 436 milh√µes. A sua l√¢mina d‚Äô√°gua abrange uma superf√≠cie em torno de 2.700 hectares. Nesse mesmo per√≠odo, segundo dados da pesquisa, o n√∫mero de liga√ß√µes de √°gua em pr√©dios residenciais e comerciais em Campina Grande aumentou em 102,9%, as quais passaram de 40.298, em 1983, para 81.796, em 2003.&lt;/p&gt;

&lt;p&gt;O clima de toda a regi√£o da bacia √© tropical quente e seco, com m√°xima de 37 ¬∞Celsius e m√≠nimas de 16 ¬∞C. A precipita√ß√£o m√©dia na regi√£o √© de 600 mm/ano, caracterizando-se um clima de semi-√°rido.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Fonte: https://pt.wikipedia.org/wiki/A√ßude_Boqueir√£o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para mais informa√ß√µes sobre a atual crise h√≠drica, acesse essa visualiza√ß√£o sobre o nosso a√ßude:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://olhonagua.insa.gov.br/#!/?id=12172&amp;amp;reservatorio=epitacio_pessoa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(nela pode ser visto tamb√©m a situa√ß√£o de outros reservatorios.)&lt;/p&gt;

&lt;h1 id=&#34;bom-vamos-ao-que-interessa&#34;&gt;Bom vamos ao que interessa ?&lt;/h1&gt;

&lt;p&gt;Vamos l√°, viemos aqui para ver algumas visualiza√ß√µes sobre o a√ßude Epitacio Pessoa, ent√£o abaixo estar√° listado 3 visualiza√ß√µes de dados
usando gr√°ficos tabulares e de todos os tipos, espero que aproveitem. &lt;em&gt;Lets Gooo!&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A primeira visualiza√ß√£o ser√° com gr√°fico de √°rea, a ideia por tr√°s dele, √© mostrar os anos em que o a√ßude esteve com sua capacidade oscilando entre 200 e 300 milh√µes de volume h√≠drico.&lt;/li&gt;
&lt;/ol&gt;

&lt;div id=&#34;vis&#34; width=300&gt;&lt;/div&gt;

&lt;script src=&#34;https://cdnjs.cloudflare.com/ajax/libs/vega/3.0.7/vega.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;https://cdnjs.cloudflare.com/ajax/libs/vega-lite/2.0.1/vega-lite.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;https://cdnjs.cloudflare.com/ajax/libs/vega-embed/3.0.0-rc7/vega-embed.js&#34;&gt;&lt;/script&gt;
&lt;script&gt;
    const spec = {
 &#34;$schema&#34;: &#34;https://vega.github.io/schema/vega-lite/v2.json&#34;,
     &#34;data&#34;: {
       &#34;url&#34;:&#34;https://api.insa.gov.br/reservatorios/12172/monitoramento&#34;,
       &#34;format&#34;: {
           &#34;type&#34;: &#34;json&#34;,
           &#34;property&#34;: &#34;volumes&#34;,
           &#34;parse&#34;: {
           &#34;DataInformacao&#34;: &#34;utc:&#39;%d/%m/%Y&#39;&#34;
               }
       }},
 &#34;vconcat&#34;: [{
    &#34;transform&#34;: [
    {&#34;filter&#34;: {&#34;field&#34;: &#34;Volume&#34;, &#34;range&#34;: [200, 300] }}
    ],
   &#34;width&#34;: 600,
   &#34;mark&#34;: &#34;area&#34;,
   &#34;encoding&#34;: {
     &#34;x&#34;: {
       &#34;field&#34;: &#34;DataInformacao&#34;,
       &#34;type&#34;: &#34;temporal&#34;,
       &#34;scale&#34;: {&#34;domain&#34;: {&#34;selection&#34;: &#34;brush&#34;}},
       &#34;axis&#34;: {&#34;title&#34;: &#34;&#34;}
     },
     &#34;y&#34;: {&#34;field&#34;: &#34;Volume&#34;,&#34;type&#34;: &#34;quantitative&#34;}
   }
 },{
    &#34;transform&#34;: [
    {&#34;filter&#34;: {&#34;field&#34;: &#34;Volume&#34;, &#34;range&#34;: [200, 300] }}
    ],
   &#34;width&#34;: 600,
   &#34;height&#34;: 80,
   &#34;mark&#34;: &#34;area&#34;,

   &#34;selection&#34;: {
     &#34;brush&#34;: {&#34;type&#34;: &#34;interval&#34;, &#34;encodings&#34;: [&#34;x&#34;]}
   },

   &#34;encoding&#34;: {
     &#34;x&#34;: {
       &#34;field&#34;: &#34;DataInformacao&#34;,
       &#34;type&#34;: &#34;temporal&#34;

     },
     &#34;y&#34;: {
       &#34;field&#34;: &#34;Volume&#34;,
       &#34;type&#34;: &#34;quantitative&#34;
     }
   }
 }]
};
    vegaEmbed(&#39;#vis&#39;, spec).catch(console.warn);
&lt;/script&gt;

&lt;p&gt;Podemos observar, ao aproximar em um trecho de ano expecifico os anos que oscilaram entre eses volumes de √°gua, e que ap√≥s de 2013 tivemos uma quebra brusca e ainda n√£o voltamos para esse intervalo de 200-300 milhoes de volumes c√∫bicos.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
